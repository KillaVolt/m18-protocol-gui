// *************************************************************************************************
// M18AnalyzerMain.cs
// ------------------
// Hosts the user-facing WinForms logic for the Milwaukee M18 battery analyzer GUI. This partial
// class pairs with M18AnalyzerMain.Designer.cs (UI layout) to render the form and wire up buttons,
// combo boxes, and rich text boxes. It now acts as a bridge between UI events and the authoritative
// Python implementation (m18.py), launching the script as a child process and streaming stdout/stderr
// into the existing logs. Serial port discovery still flows through SerialPortUtil.cs so the user can
// select the COM port that will be passed to Python. Every method and key line is commented to teach
// WinForms fundamentals (event registration, marshaling to the UI thread) and logging approaches.
// *************************************************************************************************

using System; // Provides core types like EventArgs, Action, and DateTime used throughout the form.
using System.Collections.Generic; // Supplies List<T> for storing serial port objects.
using System.IO; // Validates python and script paths.
using System.Linq; // Enables LINQ helpers such as Select and ToList used during logging.
using System.Threading; // Supports cancellation and timeouts.
using System.Threading.Tasks; // Enables Task.Run for background work that keeps the UI responsive.
using System.Windows.Forms; // Provides Form, control types, and dialog helpers used by WinForms.

namespace M18BatteryInfo
{
    /// <summary>
    /// The primary WinForms window that presents user controls for serial port selection,
    /// connection management, and protocol commands (idle/high/reset/health-report). This class
    /// captures events fired by buttons and other controls, marshals work to background threads so
    /// the UI does not freeze, and forwards user actions to the Python reference implementation
    /// (m18.py). It also uses <see cref="SerialPortUtil"/> to enumerate serial ports with extended
    /// metadata for the Python process to consume.
    /// </summary>
    public partial class frmMain : Form
    {
        // Hosts the interactive Python session.
        private PythonProcessController? _pythonController;
        // Persisted settings for python and script locations.
        private readonly AppSettings _settings = AppSettings.Load();
        // Tracks whether a Python command is currently in-flight (waiting for prompt).
        private bool _isPythonBusy;
        // Timeout used when waiting for Python to return to the REPL prompt.
        private readonly TimeSpan _commandTimeout = TimeSpan.FromSeconds(15);
        // Track whether the simple output RichTextBox already has content to manage newlines.
        private bool _hasAppendedLog; // Ensures we only prepend Environment.NewLine after the first log line.
        // Track whether the advanced output RichTextBox already has content.
        private bool _hasAppendedAdvancedLog; // Similar flag for the advanced log tab to avoid leading blank lines.
        // Track whether the debug output RichTextBox already has content.
        private bool _hasAppendedDebugLog; // Prevents inserting extra blank lines before first debug message.
        // Track whether the raw serial log RichTextBox already has content.
        private bool _hasAppendedSerialLog; // Prevents inserting extra blank lines before first raw serial entry.
        // Store the currently selected serial device for connection attempts.
        private SerialPortDisplay? _selectedDevice; // Persisted when user picks an item from cmbBxSerialPort.
        // Store a human-friendly device description for user messages.
        private string? _selectedDeviceDescription; // Derived from SerialPortDisplay to show manufacturer/USB metadata.

        /// <summary>
        /// Constructs the form, initializes UI components generated by the designer, and hooks up
        /// event handlers for all buttons and checkbox controls. The constructor also sets helpful
        /// tooltips and initializes the UI to a disconnected state.
        /// </summary>
        public frmMain()
        {
            InitializeComponent(); // Calls into the designer-generated control creation code.

            // Wire up button click and change handlers to their corresponding methods. Delegates are
            // created here to keep designer file clean and to demonstrate event subscription syntax.
            btnRefresh.Click += btnRefresh_Click; // Refresh list of serial ports when "Refresh" pressed.
            btnConnect.Click += btnConnect_Click; // Launch Python on the selected port when "Connect" pressed.
            btnDisconnect.Click += btnDisconnect_Click; // Stop the Python process when "Disconnect" pressed.
            btnIdle.Click += btnIdle_Click; // Ask Python to drive TX low (idle charger pin).
            btnActive.Click += btnActive_Click; // Ask Python to drive TX high (charging simulation).
            btnHealthReport.Click += btnHealthReport_Click; // Trigger multi-register read via Python health().
            btnReset.Click += btnReset_Click; // Send reset handshake through Python.
            btnCopyOutput.Click += btnCopyOutput_Click; // Copy logs to clipboard for sharing/debugging.
            chkbxTXLog.CheckedChanged += chkbxTXLog_CheckedChanged; // Toggle TX byte logging.
            chkboxRxLog.CheckedChanged += chkboxRxLog_CheckedChanged; // Toggle RX byte logging.
            btnTestFT232.Click += btnTestFT232_Click; // Run quick FT232 loopback/response test.
            cmbBxSerialPort.SelectedIndexChanged += cmbBxSerialPort_SelectedIndexChanged; // Capture selected serial port.
            FormClosing += frmMain_FormClosing; // Ensure we cleanly close serial port when form closes.

            // Default logging preferences to on to maintain parity with previous UI.
            chkbxTXLog.Checked = true; // TX log checkbox retained for compatibility.
            chkboxRxLog.Checked = true; // RX log checkbox retained for compatibility.

            // Provide friendly tooltips describing each control's purpose.
            toolTipSimpleTab.SetToolTip(btnRefresh, "Refresh the list of available serial ports."); // Helps beginners understand UI flow.
            toolTipSimpleTab.SetToolTip(btnConnect, "Connect to the selected serial port."); // Explains connection button.
            toolTipSimpleTab.SetToolTip(btnDisconnect, "Disconnect from the currently connected device."); // Clarifies safe disconnect.
            toolTipSimpleTab.SetToolTip(btnIdle, "Drive TX low (idle). Safe for connect/disconnect."); // Notes electrical effect on TX line.
            toolTipSimpleTab.SetToolTip(btnActive, "Drive TX high (active). Charger simulation."); // Indicates charger-simulation state.
            toolTipSimpleTab.SetToolTip(btnHealthReport, "Read and display a basic battery health report.");
            toolTipSimpleTab.SetToolTip(btnReset, "Send a reset signal to the connected battery.");
            toolTipSimpleTab.SetToolTip(btnCopyOutput, "Copy all output log text to the clipboard."); // Guides how to export logs.

            InitializePythonController(); // Prepare the Python process host and logging bridges.

            UpdateConnectionUi(false); // Disable connection-dependent buttons until a port opens.
        }

        /// <summary>
        /// Placeholder handler generated by WinForms designer for a tool strip button; retained to
        /// illustrate event signatures even when unused.
        /// </summary>
        private void toolStripButton1_Click(object sender, EventArgs e)
        {
            // No logic implemented. Keeping the method demonstrates the event handler pattern that
            // other buttons follow. Deleting could break designer hookups, so it stays as a template.
        }

        /// <summary>
        /// Create a fresh PythonProcessController instance and wire its events into the existing log
        /// surfaces so stdout/stderr are mirrored into the UI.
        /// </summary>
        private void InitializePythonController()
        {
            _pythonController?.Dispose();
            _pythonController = new PythonProcessController(_settings.PythonExecutablePath, _settings.ScriptPath);
            _pythonController.OutputReceived += line => AppendPythonLog(line, false);
            _pythonController.ErrorReceived += line => AppendPythonLog(line, true);
            _pythonController.PromptDetected += () => SetPythonBusy(false);
            _pythonController.Exited += exitCode =>
            {
                AppendLogBoth($"Python process exited (code: {exitCode?.ToString() ?? "unknown"}).");
                SetPythonBusy(false);
                UpdateConnectionUi(false);
            };
        }

        /// <summary>
        /// Stub for tooltip popup events. Included for completeness to show how ToolTip can be
        /// customized if desired.
        /// </summary>
        private void toolTipReset_Popup(object sender, PopupEventArgs e)
        {
            // Intentionally blank. If we wanted dynamic tooltips, this would adjust size or text.
        }

        /// <summary>
        /// Executes when the form finishes loading. We immediately refresh serial ports so the
        /// combo box is populated before the user interacts with it.
        /// </summary>
        private void frmMain_Load(object sender, EventArgs e)
        {
            RefreshSerialPorts(); // Kick off device enumeration via SerialPortUtil.
        }

        /// <summary>
        /// Auto-generated click handler for label controls; retained as teaching stub.
        /// </summary>
        private void lblResponseLength_Click(object sender, EventArgs e)
        {
            // Labels typically do not need click handlers, but this stub shows the event signature.
        }

        /// <summary>
        /// Stub demonstrating how to handle PictureBox click events if interactive imagery is added.
        /// </summary>
        private void pictureBox1_Click(object sender, EventArgs e)
        {
            // No operation required; included so readers see how to subscribe to image clicks.
        }

        /// <summary>
        /// Stub illustrating how to respond to link clicks in LinkLabel controls.
        /// </summary>
        private void linkLabel1_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            // Could open documentation URLs; left empty to avoid unintended navigation.
        }

        /// <summary>
        /// Stub demonstrating Enter events on group boxes (focus gained).
        /// </summary>
        private void grpBxSimCustomProfile_Enter(object sender, EventArgs e)
        {
            // Could be used to populate custom simulation values; no logic required today.
        }

        /// <summary>
        /// Handles the Refresh button click by logging intent and enumerating ports.
        /// </summary>
        private void btnRefresh_Click(object? sender, EventArgs e)
        {
            LogDebugAction("Requesting RefreshSerialPorts()."); // Show action in debug log for traceability.
            RefreshSerialPorts(); // Pull latest serial ports using SerialPortUtil.
        }

        /// <summary>
        /// Enumerates available serial ports, populates the combo box, and logs rich metadata for
        /// troubleshooting USB cables/adapters. Uses <see cref="SerialPortUtil.EnumerateDetailedPorts"/>.
        /// </summary>
        private void RefreshSerialPorts()
        {
            AppendLogBoth("Refreshing serial port list..."); // Inform user in both simple and debug logs.

            try
            {
                var devices = GetSerialPorts(); // Gather serial info via SetupAPI for COM mapping.

                cmbBxSerialPort.Items.Clear(); // Reset combo box so old entries do not linger.
                foreach (var device in devices)
                {
                    cmbBxSerialPort.Items.Add(device); // Add serial record; ToString() shows DisplayName.
                    AppendLogBoth($"Found serial port {device.DisplayName}"); // Echo discovery to the log.
                }

                AppendDebugLog($"RefreshSerialPorts(): {devices.Count} serial port(s) detected."); // Debug summary count.
                foreach (var device in devices)
                {
                    var sourceLabel = string.IsNullOrWhiteSpace(device.Source) ? "Unknown source" : device.Source; // Prefer readable source text.
                    AppendDebugLog($" - {device.DisplayName} (source: {sourceLabel})."); // Include display name and source origin.
                    AppendDebugLog($"   Details: description='{device.Description}', serial='{device.UsbSerialNumber}', COM='{device.PortName}', manufacturer='{device.Manufacturer ?? "(none)"}'"); // Show manufacturer/hardware IDs for driver troubleshooting.
                }

                if (devices.Count == 0)
                {
                    AppendLogBoth("No serial ports detected."); // Warn user if no cables are found (e.g., driver missing).
                }
                else
                {
                    cmbBxSerialPort.SelectedIndex = 0; // Auto-select first device to streamline connection flow.
                }

                if (cmbBxSerialPort.SelectedItem is null)
                {
                    _selectedDevice = null; // Reset selection tracking if nothing is selected.
                    _selectedDeviceDescription = null; // Clear human-friendly description too.
                }
            }
            catch (Exception ex)
            {
                LogError("Error while refreshing serial ports", ex); // Surface exceptions with MessageBox to aid debugging.
            }
        }

        /// <summary>
        /// Captures combo-box selection changes so we know which serial port to open.
        /// </summary>
        private void cmbBxSerialPort_SelectedIndexChanged(object? sender, EventArgs e)
        {
            if (cmbBxSerialPort.SelectedItem is SerialPortDisplay selected)
            {
                _selectedDevice = selected; // Save serial port entry for connection.
                _selectedDeviceDescription = selected.DisplayName; // Save descriptive text for user prompts.
                AppendDebugLog($"Selected serial port set to {selected.DisplayName} (source: {selected.Source})."); // Log the selection for trace.
            }
            else
            {
                _selectedDevice = null; // Clear cached name if selection is removed.
                _selectedDeviceDescription = null; // Clear description as well.
            }
        }

        /// <summary>
        /// Launches the Python process against the selected port. Validates configured paths before
        /// starting so the backend can run without blocking the UI thread.
        /// </summary>
        private async void btnConnect_Click(object? sender, EventArgs e)
        {
            LogDebugAction("Requesting Python connect."); // Debug log entry noting button press.
            if (_pythonController?.IsRunning == true)
            {
                AppendLogBoth("Python process is already running.");
                return;
            }

            if (!ValidatePythonPaths())
            {
                return;
            }

            var selectedPort = _selectedDevice?.PortName ?? string.Empty;
            if (string.IsNullOrWhiteSpace(selectedPort))
            {
                AppendLog("No serial port selected. Please choose a port before connecting.");
                MessageBox.Show("Please select a serial port before connecting.", "Python Process", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            try
            {
                UpdatePythonPathsFromSettings();
                AppendLogBoth($"Starting m18.py using {_settings.PythonExecutablePath} on port {selectedPort}...");
                await _pythonController!.StartAsync(selectedPort);
                AppendLogBoth("m18.py launched. Waiting for prompt...");
                UpdateConnectionUi(true);
            }
            catch (Exception ex)
            {
                AppendLogBoth($"Failed to start m18.py: {ex.Message}");
                MessageBox.Show($"Failed to start m18.py: {ex.Message}", "Python Process Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                UpdateConnectionUi(false);
            }
        }

        /// <summary>
        /// Handles Disconnect button clicks by invoking <see cref="DisconnectAsync"/> and logging the
        /// action for debugging. Uses async void because it is an event handler.
        /// </summary>
        private async void btnDisconnect_Click(object? sender, EventArgs e)
        {
            LogDebugAction(FormatLogMessage("btnDisconnect pressed - requesting DisconnectAsync().")); // Timestamped debug entry.
            await DisconnectAsync(); // Attempt to close the python process safely.
        }

        /// <summary>
        /// Closes the active python process if present, optionally informing the user via MessageBox.
        /// </summary>
        private async Task DisconnectAsync(bool showUserMessages = true)
        {
            if (_pythonController == null || !_pythonController.IsRunning)
            {
                var message = "Disconnect requested, but the Python process is not running."; // Friendly explanation.
                AppendDebugLog(FormatLogMessage(message)); // Debug log for trace.
                if (showUserMessages)
                {
                    AppendLog(message); // Display in primary log when requested by user (e.g., clicking Disconnect).
                    MessageBox.Show(message, "Python Process", MessageBoxButtons.OK, MessageBoxIcon.Information); // Notify via modal dialog.
                }
                UpdateConnectionUi(false); // Reset UI state regardless.
                return; // Exit early when nothing to close.
            }

            AppendLogBoth("Stopping Python process..."); // Inform user which process is closing.

            try
            {
                await _pythonController.StopAsync(TimeSpan.FromSeconds(5));
                AppendLogBoth("Python process stopped successfully."); // Confirm closure.
            }
            catch (Exception ex)
            {
                LogError("Error while stopping Python.", ex); // Report exceptions thrown during close.
            }
            finally
            {
                UpdateConnectionUi(false); // Re-enable Connect and refresh buttons.
            }
        }

        /// <summary>
        /// Requests Python to set TX line to idle (low) via m.idle().
        /// </summary>
        private async void btnIdle_Click(object? sender, EventArgs e)
        {
            AppendDebugLog(FormatLogMessage("btnIdle pressed - sending m.idle().")); // Trace button press.
            await SendPythonCommandAsync("m.idle()", "idle (TX low)");
        }

        /// <summary>
        /// Requests Python to set TX line high (active) via m.high().
        /// </summary>
        private async void btnActive_Click(object? sender, EventArgs e)
        {
            AppendDebugLog(FormatLogMessage("btnActive pressed - sending m.high().")); // Trace user action.
            await SendPythonCommandAsync("m.high()", "active (TX high)");
        }

        /// <summary>
        /// Initiates a comprehensive battery health report by invoking m.health() inside Python.
        /// </summary>
        private async void btnHealthReport_Click(object? sender, EventArgs e)
        {
            AppendDebugLog(FormatLogMessage("btnHealthReport pressed - sending m.health().")); // Trace user action.
            await SendPythonCommandAsync("m.health()", "health report");
        }

        /// <summary>
        /// Issues a reset command to the battery by invoking m.reset() within Python.
        /// </summary>
        private async void btnReset_Click(object? sender, EventArgs e)
        {
            LogDebugAction("Requesting Python reset command."); // Note action for trace.
            await SendPythonCommandAsync("m.reset()", "reset");
        }

        /// <summary>
        /// Copies all simple log output to the clipboard, allowing users to paste logs into emails
        /// or issue reports.
        /// </summary>
        private void btnCopyOutput_Click(object? sender, EventArgs e)
        {
            LogDebugAction("Copying output via btnCopyOutput_Click()."); // Record action.
            if (string.IsNullOrEmpty(rtbOutput.Text))
            {
                AppendLogBoth("No output to copy."); // Warn when nothing to copy.
                return; // Exit early to avoid placing empty text on clipboard.
            }

            Clipboard.SetText(rtbOutput.Text); // Use System.Windows.Forms.Clipboard to place text into OS clipboard.
            AppendLogBoth("Output copied to clipboard."); // Confirm to user.
        }

        /// <summary>
        /// Sends a command into the Python REPL and handles prompt/timeout state transitions.
        /// </summary>
        private async Task SendPythonCommandAsync(string command, string description)
        {
            if (!EnsurePythonRunning())
            {
                return;
            }

            AppendLogBoth($"Sending {description} command to Python: {command}");
            SetPythonBusy(true);

            try
            {
                var success = await _pythonController!.SendCommandAsync(command, _commandTimeout);
                if (!success)
                {
                    AppendLogBoth($"Timed out waiting for Python prompt after '{command}'. The process is still running.");
                    SetPythonBusy(false);
                }
            }
            catch (Exception ex)
            {
                SetPythonBusy(false);
                LogError($"Failed to send command '{command}' to Python.", ex);
            }
        }

        /// <summary>
        /// Ensures the Python backend is running before dispatching commands.
        /// </summary>
        private bool EnsurePythonRunning()
        {
            if (_pythonController?.IsRunning == true)
            {
                return true;
            }

            AppendLog("Python process is not running. Please connect first.");
            MessageBox.Show("Start the Python process with the Connect button before sending commands.", "Python Process", MessageBoxButtons.OK, MessageBoxIcon.Warning);
            return false;
        }

        /// <summary>
        /// Validate configured paths and prompt the user to locate python.exe or m18.py when missing.
        /// </summary>
        private bool ValidatePythonPaths()
        {
            if (!File.Exists(_settings.ScriptPath))
            {
                var message = $"Could not find m18.py at '{_settings.ScriptPath}'. Please locate the script.";
                AppendLogBoth(message);
                MessageBox.Show(message, "m18.py Missing", MessageBoxButtons.OK, MessageBoxIcon.Error);

                using var dialog = new OpenFileDialog
                {
                    Filter = "Python Script|m18.py;*.py|All Files|*.*",
                    Title = "Select m18.py",
                    FileName = "m18.py"
                };

                if (dialog.ShowDialog() != DialogResult.OK)
                {
                    return false;
                }

                _settings.ScriptPath = dialog.FileName;
                _settings.Save();
                InitializePythonController();
            }

            if (PathLooksLikeFile(_settings.PythonExecutablePath) && !File.Exists(_settings.PythonExecutablePath))
            {
                var message = $"Could not find python executable at '{_settings.PythonExecutablePath}'. Please locate python.exe.";
                AppendLogBoth(message);
                MessageBox.Show(message, "Python Missing", MessageBoxButtons.OK, MessageBoxIcon.Error);

                using var dialog = new OpenFileDialog
                {
                    Filter = "Python|python.exe;python|All Files|*.*",
                    Title = "Select python executable",
                    FileName = "python.exe"
                };

                if (dialog.ShowDialog() != DialogResult.OK)
                {
                    return false;
                }

                _settings.PythonExecutablePath = dialog.FileName;
                _settings.Save();
                InitializePythonController();
            }

            return true;
        }

        private static bool PathLooksLikeFile(string path)
        {
            return path.Contains(Path.DirectorySeparatorChar) || path.Contains(Path.AltDirectorySeparatorChar);
        }

        /// <summary>
        /// Sync controller paths with the persisted settings in case the user updated them on disk.
        /// </summary>
        private void UpdatePythonPathsFromSettings()
        {
            if (_pythonController == null)
            {
                InitializePythonController();
            }
            else
            {
                _pythonController.PythonExecutablePath = _settings.PythonExecutablePath;
                _pythonController.ScriptPath = _settings.ScriptPath;
            }
        }

        /// <summary>
        /// Route Python stdout/stderr into the existing logs with a timestamp and error marker.
        /// </summary>
        private void AppendPythonLog(string line, bool isError)
        {
            var tagged = isError ? $"[stderr] {line}" : line;
            var formatted = FormatLogMessage(tagged);
            AppendSimpleLog(formatted);
            AppendDebugLog(formatted);
        }

        /// <summary>
        /// Update UI state to reflect Python busy/idle states and disable command buttons while a
        /// command is outstanding.
        /// </summary>
        private void SetPythonBusy(bool busy)
        {
            _isPythonBusy = busy;
            UpdateConnectionUi(_pythonController?.IsRunning == true);
        }

        /// <summary>
        /// Wrapper around SerialPortUtil to retrieve detailed device metadata, keeping the logic
        /// isolated for easier unit testing and mocking.
        /// </summary>
        private List<SerialPortDisplay> GetSerialPorts()
        {
            return SerialPortUtil.EnumerateDetailedPorts(AppendRawSerialLog); // Pass raw logger to capture detailed enumeration.
        }

        /// <summary>
        /// Executes a quick FT232 communication test against the selected device by toggling control
        /// lines and sending a byte. Helps verify USB-UART hardware is responsive.
        /// </summary>
        private async void btnTestFT232_Click(object? sender, EventArgs e)
        {
            LogDebugAction("Requesting Test FT232 operation."); // Trace user action.

            if (cmbBxSerialPort.SelectedItem is not SerialPortDisplay selectedPort)
            {
                AppendLog("No serial port selected. Please choose a port before testing."); // Provide guidance.
                MessageBox.Show("Please select a serial port before testing.", "Serial Port", MessageBoxButtons.OK, MessageBoxIcon.Warning); // Block until user acknowledges.
                return; // Abort test.
            }

            var selectedDescription = _selectedDeviceDescription ?? selectedPort.DisplayName; // Friendly name for messages.

            AppendLog($"Testing serial connectivity on {selectedDescription}..."); // Inform user test is starting.
            LogDebugAction($"Testing serial connectivity on {selectedDescription}."); // Duplicate in debug log.

            var testResult = await Task.Run(() => TestSerialDevice(selectedPort)); // Run test on background thread to keep UI fluid.

            if (testResult.Success)
            {
                AppendLog($"Device responded successfully on {selectedPort.DisplayName}."); // Success message for user.
                LogDebugAction($"Device responded successfully on {selectedPort.DisplayName}."); // Debug confirmation.
            }
            else
            {
                AppendLog($"No response / failed to communicate with device on {selectedPort.DisplayName}{(string.IsNullOrWhiteSpace(testResult.ErrorMessage) ? string.Empty : $": {testResult.ErrorMessage}")}."); // Provide failure details.
                LogDebugAction($"No response / failed to communicate with device on {selectedPort.DisplayName}{(string.IsNullOrWhiteSpace(testResult.ErrorMessage) ? string.Empty : $": {testResult.ErrorMessage}")}."); // Debug echo.
            }
        }

        /// <summary>
        /// Opens the specified device with the serial settings and performs a minimal
        /// control-line toggle plus a single-byte write to check for driver/hardware responsiveness.
        /// </summary>
        private static (bool Success, string? ErrorMessage) TestSerialDevice(SerialPortDisplay device)
        {
            try
            {
                using var serialPort = new SerialPortConnection(device, null); // Open serial handle with default logger.
                serialPort.SetDtr(true); // Assert DTR to mimic idle charger line initially.
                serialPort.SetBreak(true); // Assert BREAK to drive TX low.
                serialPort.SetDtr(false); // Toggle DTR to confirm control-line responsiveness.
                serialPort.SetBreak(false); // Release BREAK to drive TX high.

                serialPort.WriteBytes(new byte[] { 0x00 }); // Send a single zero byte out TX to verify TX data path.

                return (true, null); // Success indicates driver and hardware are reachable.
            }
            catch (Exception ex)
            {
                return (false, ex.Message); // Return error message so caller can log it.
            }
        }

        /// <summary>
        /// Appends a message to the primary output log after prefixing with a timestamp.
        /// </summary>
        private void AppendLog(string message)
        {
            AppendSimpleLog(FormatLogMessage(message)); // Reuse helper to add timestamp and write to RichTextBox.
        }

        /// <summary>
        /// Appends a message to both the simple log and debug log so the text appears in two tabs.
        /// </summary>
        private void AppendLogBoth(string message)
        {
            var formatted = FormatLogMessage(message); // Create timestamped text once.
            AppendSimpleLog(formatted); // Show in user-friendly log window.
            AppendDebugLog(formatted); // Also show in verbose debug tab.
        }

        /// <summary>
        /// Writes text into the primary rich text box, marshaling to the UI thread if necessary so
        /// background tasks can safely log without cross-thread exceptions.
        /// </summary>
        private void AppendSimpleLog(string formattedMessage)
        {
            if (rtbOutput.InvokeRequired)
            {
                rtbOutput.Invoke(new Action(() => AppendSimpleLog(formattedMessage))); // Marshal to UI thread.
                return; // Exit current thread path.
            }

            var prefix = _hasAppendedLog ? Environment.NewLine : string.Empty; // Insert newline if previous messages exist.
            rtbOutput.AppendText($"{prefix}{formattedMessage}"); // Append timestamped message.
            rtbOutput.SelectionStart = rtbOutput.TextLength; // Move caret to end to keep view updated.
            rtbOutput.ScrollToCaret(); // Auto-scroll so latest text is visible.
            _hasAppendedLog = true; // Record that log has content.
        }

        /// <summary>
        /// Writes text into the advanced output rich text box (used for protocol-level logs),
        /// marshaling to the UI thread when invoked from background tasks.
        /// </summary>
        private void AppendAdvancedLog(string formattedMessage)
        {
            if (rtbAdvOutput.InvokeRequired)
            {
                rtbAdvOutput.Invoke(new Action(() => AppendAdvancedLog(formattedMessage))); // Ensure UI-thread access.
                return; // Prevent cross-thread access.
            }

            var prefix = _hasAppendedAdvancedLog ? Environment.NewLine : string.Empty; // Add newline after first entry.
            rtbAdvOutput.AppendText($"{prefix}{formattedMessage}"); // Append formatted message.
            rtbAdvOutput.SelectionStart = rtbAdvOutput.TextLength; // Move caret to end.
            rtbAdvOutput.ScrollToCaret(); // Auto-scroll to maintain visibility.
            _hasAppendedAdvancedLog = true; // Track that text exists.
        }

        /// <summary>
        /// Creates a timestamped log message string using millisecond resolution to help correlate
        /// serial I/O timing.
        /// </summary>
        private string FormatLogMessage(string message)
        {
            return $"{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} - {message}"; // Compose human-readable timestamp + message.
        }

        /// <summary>
        /// Writes a formatted message to all log panes (simple, advanced, debug) to keep them in sync.
        /// </summary>
        private void AppendProtocolLog(string message)
        {
            var formattedMessage = FormatLogMessage(message); // Timestamp once for consistency.
            AppendSimpleLog(formattedMessage); // User-friendly log.
            AppendAdvancedLog(formattedMessage); // Protocol log.
            AppendDebugLog(formattedMessage); // Debug log.
        }

        /// <summary>
        /// Logs an error context with exception details and shows a MessageBox to alert the user.
        /// </summary>
        private void LogError(string context, Exception exception)
        {
            var fullMessage = $"{context} Error details: {exception}"; // Combine context and exception message/stack trace.
            AppendLogBoth(fullMessage); // Write to logs for persistence.
            MessageBox.Show(fullMessage, "Serial Port Error", MessageBoxButtons.OK, MessageBoxIcon.Error); // Display blocking error dialog.
        }

        /// <summary>
        /// The legacy TX/RX log toggles remain for UI continuity; Python output is always captured to
        /// comply with the requirement that no lines are dropped.
        /// </summary>
        private void chkbxTXLog_CheckedChanged(object? sender, EventArgs e) => AppendDebugLog(FormatLogMessage("TX log checkbox toggled (Python output remains enabled)."));

        /// <summary>
        /// The legacy RX log toggle is informational only for the Python bridge.
        /// </summary>
        private void chkboxRxLog_CheckedChanged(object? sender, EventArgs e) => AppendDebugLog(FormatLogMessage("RX log checkbox toggled (Python output remains enabled)."));

        /// <summary>
        /// Convenience wrapper to send a debug message to the dedicated debug log pane.
        /// </summary>
        private void LogDebugAction(string message)
        {
            AppendDebugLog(message); // Delegates to AppendDebugLog for thread-safe logging.
        }

        /// <summary>
        /// Appends text to the debug rich text box with optional timestamping. Invocations from
        /// background threads are marshaled to the UI thread to avoid InvalidOperationException.
        /// </summary>
        private void AppendDebugLog(string message)
        {
            if (rtbDebugOutput.InvokeRequired)
            {
                rtbDebugOutput.Invoke(new Action(() => AppendDebugLog(message))); // Marshal to UI thread if needed.
                return; // Stop processing on worker thread.
            }

            var prefix = _hasAppendedDebugLog ? Environment.NewLine : string.Empty; // Add newline after first message.
            var formatted = message.Contains("- ") ? message : FormatLogMessage(message); // Preserve existing timestamps if provided.
            rtbDebugOutput.AppendText($"{prefix}{formatted}"); // Write to debug output box.
            rtbDebugOutput.SelectionStart = rtbDebugOutput.TextLength; // Move caret to end.
            rtbDebugOutput.ScrollToCaret(); // Auto-scroll to newest entry.
            _hasAppendedDebugLog = true; // Note content exists.
        }

        /// <summary>
        /// Writes text into the raw serial log rich text box, mirroring SerialPort actions for visibility.
        /// Background threads are marshaled to the UI thread to avoid cross-thread exceptions.
        /// </summary>
        private void AppendRawSerialLog(string message)
        {
            if (rtbD2xxLog.InvokeRequired)
            {
                rtbD2xxLog.Invoke(new Action(() => AppendRawSerialLog(message))); // Marshal to UI thread if needed.
                return; // Stop processing on worker thread.
            }

            var prefix = _hasAppendedSerialLog ? Environment.NewLine : string.Empty; // Add newline after first message.
            var formatted = message.Contains("- ") ? message : FormatLogMessage(message); // Preserve existing timestamps if provided.
            rtbD2xxLog.AppendText($"{prefix}{formatted}"); // Write to raw serial output box.
            rtbD2xxLog.SelectionStart = rtbD2xxLog.TextLength; // Move caret to end.
            rtbD2xxLog.ScrollToCaret(); // Auto-scroll to newest entry.
            _hasAppendedSerialLog = true; // Note content exists.
        }

        /// <summary>
        /// Enables or disables UI controls based on connection state so users cannot issue protocol
        /// commands before opening a port.
        /// </summary>
        private void UpdateConnectionUi(bool connected)
        {
            btnConnect.Enabled = !connected; // Disable Connect when connected to prevent double opens.
            btnDisconnect.Enabled = connected; // Enable Disconnect to allow clean closure.
            var commandsEnabled = connected && !_isPythonBusy;
            btnIdle.Enabled = commandsEnabled; // Only allow TX toggling when process is ready.
            btnActive.Enabled = commandsEnabled; // Only allow TX toggling when process is ready.
            btnHealthReport.Enabled = commandsEnabled; // Health report requires running process.
            btnReset.Enabled = commandsEnabled; // Reset requires running process.
            btnCopyOutput.Enabled = true; // Copy is always allowed because it is read-only.
            btnTestFT232.Enabled = !connected; // Prevent running FT232 test while another session holds the port.
            cmbBxSerialPort.Enabled = !connected; // Lock selection to avoid confusion while connected.
            btnRefresh.Enabled = !connected; // Avoid refresh while port is open to prevent handle conflicts.
        }

        /// <summary>
        /// Attempts to disconnect gracefully when the form is closing. This prevents dangling COM
        /// handles and leaves TX in idle (safe) state.
        /// </summary>
        private async void frmMain_FormClosing(object? sender, FormClosingEventArgs e)
        {
            AppendDebugLog(FormatLogMessage("Form closing requested - attempting clean disconnect.")); // Trace closure intent.

            try
            {
                await DisconnectAsync(false); // Do not show user messages to avoid blocking closure.
            }
            catch (Exception ex)
            {
                AppendDebugLog(FormatLogMessage($"Form closing disconnect encountered an error: {ex.GetType().Name} - {ex.Message}")); // Log but do not rethrow to avoid crash.
            }
        }

        /// <summary>
        /// Stub for RichTextBox text change event; kept for demonstration of event wiring.
        /// </summary>
        private void rtbOutput_TextChanged(object sender, EventArgs e)
        {
            // Could auto-save logs or update counters; not needed currently.
        }

        /// <summary>
        /// Duplicate combo box change handler generated by designer; kept for completeness.
        /// </summary>
        private void cmbBxSerialPort_SelectedIndexChanged_1(object sender, EventArgs e)
        {
            // All selection logic handled in cmbBxSerialPort_SelectedIndexChanged; this remains empty.
        }

        /// <summary>
        /// Stub button handler reserved for future UI actions.
        /// </summary>
        private void button1_Click(object sender, EventArgs e)
        {
            // Intentionally left blank to illustrate event handler shape.
        }

        /// <summary>
        /// Sends a raw byte (0xAA) and waits for a response to validate echo/loopback behavior on
        /// the open serial port. This is similar to a ping test for UART communications.
        /// </summary>
        private void btnTestEcho_Click(object sender, EventArgs e)
        {
            rtbDebugOutput.AppendText($"{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} - Raw echo test is not available when controlling the Python reference implementation.\n");
        }
    }
}
