// *************************************************************************************************
// M18AnalyzerMain.cs
// ------------------
// Hosts the user-facing WinForms logic for the Milwaukee M18 battery analyzer GUI. This partial
// class pairs with M18AnalyzerMain.Designer.cs (UI layout) to render the form and wire up buttons,
// combo boxes, and rich text boxes. It acts as a bridge between the UI events and the lower-level
// serial protocol implementation in M18Protocol.cs as well as the COM port discovery helper
// SerialPortUtil.cs. Every method and key line is commented to teach WinForms fundamentals (event
// registration, marshaling to the UI thread), serial programming (driving DTR/Break for idle/high),
// and logging approaches. Reading the comments alone should explain how the GUI controls map to the
// electrical behavior on the FT232/COM port pins and how the protocol layer is orchestrated.
// *************************************************************************************************

using System; // Provides core types like EventArgs, Action, and DateTime used throughout the form.
using System.Collections.Generic; // Supplies List<T> for storing SerialPortDisplay objects.
using System.IO.Ports; // Exposes SerialPort and related enumerations (Parity, StopBits) for UART control.
using System.Linq; // Enables LINQ helpers such as Select and ToList used during logging.
using System.Threading.Tasks; // Enables Task.Run for background work that keeps the UI responsive.
using System.Windows.Forms; // Provides Form, control types, and dialog helpers used by WinForms.

namespace M18BatteryInfo
{
    /// <summary>
    /// The primary WinForms window that presents user controls for serial-port selection,
    /// connection management, and protocol commands (idle/high/reset/health-report). This class
    /// captures events fired by buttons and other controls, marshals work to background threads so
    /// the UI does not freeze, and forwards user actions to <see cref="M18Protocol"/> which drives
    /// the UART (TX) line high/low and exchanges bytes with the battery BMS. It also uses
    /// <see cref="SerialPortUtil"/> to enumerate available COM ports with extended metadata.
    /// </summary>
    public partial class frmMain : Form
    {
        // Backing field holding the active protocol connection. Null means no port is open.
        private M18Protocol? _protocol; // M18Protocol manipulates SerialPort.BreakState/DtrEnable to emulate charger signals.
        // Track whether the simple output RichTextBox already has content to manage newlines.
        private bool _hasAppendedLog; // Ensures we only prepend Environment.NewLine after the first log line.
        // Track whether the advanced output RichTextBox already has content.
        private bool _hasAppendedAdvancedLog; // Similar flag for the advanced log tab to avoid leading blank lines.
        // Track whether the debug output RichTextBox already has content.
        private bool _hasAppendedDebugLog; // Prevents inserting extra blank lines before first debug message.
        // Store the currently selected COM port name for connection attempts.
        private string? _selectedPortName; // Persisted when user picks an item from cmbBxSerialPort.
        // Store a human-friendly port description for user messages.
        private string? _selectedPortDescription; // Derived from SerialPortDisplay to show manufacturer/USB metadata.

        /// <summary>
        /// Constructs the form, initializes UI components generated by the designer, and hooks up
        /// event handlers for all buttons and checkbox controls. The constructor also sets helpful
        /// tooltips and initializes the UI to a disconnected state.
        /// </summary>
        public frmMain()
        {
            InitializeComponent(); // Calls into the designer-generated control creation code.

            // Wire up button click and change handlers to their corresponding methods. Delegates are
            // created here to keep designer file clean and to demonstrate event subscription syntax.
            btnRefresh.Click += btnRefresh_Click; // Refresh list of serial ports when "Refresh" pressed.
            btnConnect.Click += btnConnect_Click; // Attempt to open serial port when "Connect" pressed.
            btnDisconnect.Click += btnDisconnect_Click; // Close serial port when "Disconnect" pressed.
            btnIdle.Click += btnIdle_Click; // Drive TX low (Break/DTR asserted) to simulate idle charger pin.
            btnActive.Click += btnActive_Click; // Drive TX high (Break/DTR deasserted) to simulate charging.
            btnHealthReport.Click += btnHealthReport_Click; // Trigger multi-register read to show battery stats.
            btnReset.Click += btnReset_Click; // Send reset handshake (BREAK + SYNC byte) to battery.
            btnCopyOutput.Click += btnCopyOutput_Click; // Copy logs to clipboard for sharing/debugging.
            chkbxTXLog.CheckedChanged += chkbxTXLog_CheckedChanged; // Toggle TX byte logging.
            chkboxRxLog.CheckedChanged += chkboxRxLog_CheckedChanged; // Toggle RX byte logging.
            btnTestFT232.Click += btnTestFT232_Click; // Run quick FT232 loopback/response test.
            cmbBxSerialPort.SelectedIndexChanged += cmbBxSerialPort_SelectedIndexChanged; // Capture selected COM port.
            FormClosing += frmMain_FormClosing; // Ensure we cleanly close serial port when form closes.

            // Default logging preferences to on so that users see both TX and RX traffic.
            chkbxTXLog.Checked = true; // Enables printing TX bytes through M18Protocol.TxLogger.
            chkboxRxLog.Checked = true; // Enables printing RX bytes through M18Protocol.RxLogger.

            // Provide friendly tooltips describing each control's purpose.
            toolTipSimpleTab.SetToolTip(btnRefresh, "Refresh the list of available serial ports."); // Helps beginners understand UI flow.
            toolTipSimpleTab.SetToolTip(btnConnect, "Connect to the selected serial port."); // Explains connection button.
            toolTipSimpleTab.SetToolTip(btnDisconnect, "Disconnect from the currently connected device."); // Clarifies safe disconnect.
            toolTipSimpleTab.SetToolTip(btnIdle, "Drive TX low (idle). Safe for connect/disconnect."); // Notes electrical effect on TX line.
            toolTipSimpleTab.SetToolTip(btnActive, "Drive TX high (active). Charger simulation."); // Indicates charger-simulation state.
            toolTipSimpleTab.SetToolTip(btnHealthReport, "Read and display a basic battery health report."); // References M18Protocol.HealthReport.
            toolTipSimpleTab.SetToolTip(btnReset, "Send a reset signal to the connected battery."); // Tied to M18Protocol.Reset handshake.
            toolTipSimpleTab.SetToolTip(btnCopyOutput, "Copy all output log text to the clipboard."); // Guides how to export logs.

            UpdateConnectionUi(false); // Disable connection-dependent buttons until a port opens.
        }

        /// <summary>
        /// Placeholder handler generated by WinForms designer for a tool strip button; retained to
        /// illustrate event signatures even when unused.
        /// </summary>
        private void toolStripButton1_Click(object sender, EventArgs e)
        {
            // No logic implemented. Keeping the method demonstrates the event handler pattern that
            // other buttons follow. Deleting could break designer hookups, so it stays as a template.
        }

        /// <summary>
        /// Stub for tooltip popup events. Included for completeness to show how ToolTip can be
        /// customized if desired.
        /// </summary>
        private void toolTipReset_Popup(object sender, PopupEventArgs e)
        {
            // Intentionally blank. If we wanted dynamic tooltips, this would adjust size or text.
        }

        /// <summary>
        /// Executes when the form finishes loading. We immediately refresh serial ports so the
        /// combo box is populated before the user interacts with it.
        /// </summary>
        private void frmMain_Load(object sender, EventArgs e)
        {
            RefreshSerialPorts(); // Kick off port enumeration via SerialPortUtil.
        }

        /// <summary>
        /// Auto-generated click handler for label controls; retained as teaching stub.
        /// </summary>
        private void lblResponseLength_Click(object sender, EventArgs e)
        {
            // Labels typically do not need click handlers, but this stub shows the event signature.
        }

        /// <summary>
        /// Stub demonstrating how to handle PictureBox click events if interactive imagery is added.
        /// </summary>
        private void pictureBox1_Click(object sender, EventArgs e)
        {
            // No operation required; included so readers see how to subscribe to image clicks.
        }

        /// <summary>
        /// Stub illustrating how to respond to link clicks in LinkLabel controls.
        /// </summary>
        private void linkLabel1_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            // Could open documentation URLs; left empty to avoid unintended navigation.
        }

        /// <summary>
        /// Stub demonstrating Enter events on group boxes (focus gained).
        /// </summary>
        private void grpBxSimCustomProfile_Enter(object sender, EventArgs e)
        {
            // Could be used to populate custom simulation values; no logic required today.
        }

        /// <summary>
        /// Handles the Refresh button click by logging intent and enumerating ports.
        /// </summary>
        private void btnRefresh_Click(object? sender, EventArgs e)
        {
            LogDebugAction("Requesting RefreshSerialPorts()."); // Show action in debug log for traceability.
            RefreshSerialPorts(); // Pull latest COM ports using SerialPortUtil.
        }

        /// <summary>
        /// Enumerates available serial ports, populates the combo box, and logs rich metadata for
        /// troubleshooting USB cables/adapters. Uses <see cref="SerialPortUtil.EnumerateDetailedPorts"/>.
        /// </summary>
        private void RefreshSerialPorts()
        {
            AppendLogBoth("Refreshing serial port list..."); // Inform user in both simple and debug logs.

            try
            {
                var ports = GetSerialPortInfos(); // Gather COM port info via SerialPortUtil (uses SetupAPI).

                cmbBxSerialPort.Items.Clear(); // Reset combo box so old entries do not linger.
                foreach (var port in ports)
                {
                    cmbBxSerialPort.Items.Add(port); // Add SerialPortDisplay; ToString() shows DisplayName.
                    AppendLogBoth($"Found port {port.DisplayName}"); // Echo discovery to the log.
                }

                AppendDebugLog($"RefreshSerialPorts(): {ports.Count} port(s) detected."); // Debug summary count.
                foreach (var port in ports)
                {
                    var sourceLabel = string.IsNullOrWhiteSpace(port.Source) ? "Unknown source" : port.Source; // Prefer readable source text.
                    AppendDebugLog($" - {port.DisplayName} (source: {sourceLabel})."); // Include display name and source origin.
                    AppendDebugLog($"   Details: description='{port.DeviceDescription ?? "(none)"}', manufacturer='{port.Manufacturer ?? "(none)"}', hwid='{port.HardwareIds ?? "(none)"}'"); // Show manufacturer/hardware IDs for driver troubleshooting.
                }

                if (ports.Count == 0)
                {
                    AppendLogBoth("No serial ports detected."); // Warn user if no COM ports are found (e.g., driver missing).
                }
                else
                {
                    cmbBxSerialPort.SelectedIndex = 0; // Auto-select first port to streamline connection flow.
                }

                if (cmbBxSerialPort.SelectedItem is null)
                {
                    _selectedPortName = null; // Reset selection tracking if nothing is selected.
                    _selectedPortDescription = null; // Clear human-friendly description too.
                }
            }
            catch (Exception ex)
            {
                LogError("Error while refreshing serial ports", ex); // Surface exceptions with MessageBox to aid debugging.
            }
        }

        /// <summary>
        /// Captures combo-box selection changes so we know which COM port to open.
        /// </summary>
        private void cmbBxSerialPort_SelectedIndexChanged(object? sender, EventArgs e)
        {
            if (cmbBxSerialPort.SelectedItem is SerialPortDisplay selected)
            {
                _selectedPortName = selected.PortName; // Save COM port name (e.g., COM3) for connection.
                _selectedPortDescription = selected.DeviceDescription ?? selected.DisplayName; // Save descriptive text for user prompts.
                AppendDebugLog($"Selected port set to {selected.DisplayName} (source: {selected.Source})."); // Log the selection for trace.
            }
            else
            {
                _selectedPortName = null; // Clear cached name if selection is removed.
                _selectedPortDescription = null; // Clear description as well.
            }
        }

        /// <summary>
        /// Opens a serial connection using the selected port. Ensures any existing connection is
        /// closed first, then spins up <see cref="M18Protocol"/> on a background thread to avoid UI
        /// blocking while the FTDI driver initializes the UART pins.
        /// </summary>
        private async void btnConnect_Click(object? sender, EventArgs e)
        {
            LogDebugAction("Requesting Connect()."); // Debug log entry noting button press.
            if (cmbBxSerialPort.SelectedItem is not SerialPortDisplay selectedPort)
            {
                AppendLog("No serial port selected. Please choose a port before connecting."); // User guidance when no selection exists.
                MessageBox.Show("Please select a serial port before connecting.", "Serial Port", MessageBoxButtons.OK, MessageBoxIcon.Warning); // Modal dialog prevents accidental action.
                return; // Abort connect flow.
            }

            if (_protocol != null)
            {
                if (string.Equals(_protocol.port.PortName, selectedPort.PortName, StringComparison.OrdinalIgnoreCase))
                {
                    AppendLogBoth($"Port {selectedPort.PortName} is already open. Ignoring duplicate connect request."); // Avoid reopening same port.
                    MessageBox.Show($"{selectedPort.PortName} is already open.", "Serial Port", MessageBoxButtons.OK, MessageBoxIcon.Information); // Notify user.
                    return; // Exit without reopening.
                }

                AppendLogBoth($"A different port ({_protocol.port.PortName}) is currently open. Closing it before opening {selectedPort.PortName}..."); // Explain why we close first.
                await DisconnectAsync(); // Close current protocol instance to free COM port handle.
            }

            var selectedDescription = _selectedPortDescription ?? selectedPort.DisplayName; // Build friendly text for status lines.

            AppendLogBoth($"Attempting to open {selectedDescription} with settings: 4800 baud, 8 data bits, parity None, stop bits Two, handshake None."); // Describe UART config so readers learn standard serial settings.
            AppendDebugLog("Serial connection will set TX low (idle) after open."); // Note initial electrical state (BreakState/DTR true).

            try
            {
                await Task.Run(() => _protocol = new M18Protocol(selectedPort.PortName)); // Instantiate protocol off-UI thread; constructor opens SerialPort and drives TX idle.
                ApplyProtocolLoggingPreferences(); // Sync checkbox states into protocol PrintTx/PrintRx and hook log delegates.
                AppendLogBoth($"{selectedDescription} opened successfully."); // Confirm connection to user.
                UpdateConnectionUi(true); // Toggle button enabled states to reflect connected status.
            }
            catch (Exception ex)
            {
                _protocol = null; // Ensure no dangling protocol reference if open failed.
                LogError($"Failed to open {selectedDescription}.", ex); // Show error details.
                UpdateConnectionUi(false); // Re-enable connection buttons so user can retry.
            }
        }

        /// <summary>
        /// Handles Disconnect button clicks by invoking <see cref="DisconnectAsync"/> and logging the
        /// action for debugging. Uses async void because it is an event handler.
        /// </summary>
        private async void btnDisconnect_Click(object? sender, EventArgs e)
        {
            LogDebugAction(FormatLogMessage("btnDisconnect pressed - requesting DisconnectAsync().")); // Timestamped debug entry.
            await DisconnectAsync(); // Attempt to close the serial port and dispose protocol safely.
        }

        /// <summary>
        /// Closes the active protocol/serial port if present, optionally informing the user via
        /// MessageBox. Runs on a background thread to prevent UI freezes if the driver blocks.
        /// </summary>
        private async Task DisconnectAsync(bool showUserMessages = true)
        {
            if (_protocol == null)
            {
                var message = "Disconnect requested, but no serial port is currently open."; // Friendly explanation.
                AppendDebugLog(FormatLogMessage(message)); // Debug log for trace.
                if (showUserMessages)
                {
                    AppendLog(message); // Display in primary log when requested by user (e.g., clicking Disconnect).
                    MessageBox.Show(message, "Serial Port", MessageBoxButtons.OK, MessageBoxIcon.Information); // Notify via modal dialog.
                }
                UpdateConnectionUi(false); // Reset UI state regardless.
                return; // Exit early when nothing to close.
            }

            AppendLogBoth($"Closing {_protocol.port.PortName}..."); // Inform user which COM port is closing.

            try
            {
                await Task.Run(() =>
                {
                    if (_protocol.port.IsOpen)
                    {
                        _protocol.idle(); // Set TX to idle (safe state) before closing.
                        _protocol.port.Close(); // Close the underlying SerialPort.
                    }
                }); // Execute Close on background thread; sets TX idle then disposes SerialPort.
                AppendLogBoth($"{_protocol.port.PortName} closed successfully."); // Confirm closure.
            }
            catch (Exception ex)
            {
                LogError($"Error while closing {_protocol.port.PortName}.", ex); // Report exceptions thrown during close.
            }
            finally
            {
                _protocol = null; // Drop reference to release resources and signal disconnected state.
                UpdateConnectionUi(false); // Re-enable Connect and refresh buttons.
            }
        }

        /// <summary>
        /// Sets TX line to idle (low) by calling <see cref="M18Protocol.Idle"/>. Idle corresponds to
        /// SerialPort.BreakState = true and DtrEnable = true, which on FT232 asserts BREAK (logic 0)
        /// and DTR simultaneously, keeping the battery safe to connect/disconnect.
        /// </summary>
        private async void btnIdle_Click(object? sender, EventArgs e)
        {
            AppendDebugLog(FormatLogMessage("btnIdle pressed - calling _protocol.Idle().")); // Trace button press.
            if (!EnsureConnected())
            {
                return; // Bail out if no active protocol object.
            }

            AppendDebugLog(FormatLogMessage("Invoking _protocol.Idle() to drive TX low.")); // Explain electrical effect.
            try
            {
                await Task.Run(() => _protocol!.idle()); // Background call to avoid UI hiccup; idle toggles BreakState/DTR.
                AppendLogBoth("TX set to Idle (low). Safe to connect or disconnect battery."); // Teach user about safe state.
                AppendDebugLog(FormatLogMessage(
                    $"TX State after Idle: BreakState={_protocol!.port.BreakState}, DtrEnable={_protocol.port.DtrEnable}, RtsEnable={_protocol.port.RtsEnable}"
                )); // Log resulting control-line states.
            }
            catch (Exception ex)
            {
                LogError("Failed to set TX to Idle.", ex); // Show error if driver throws.
            }
        }

        /// <summary>
        /// Drives TX line high (active) using <see cref="M18Protocol.High"/>. High corresponds to
        /// SerialPort.BreakState = false and DtrEnable = false, emulating a charger engaging the
        /// battery's communication line.
        /// </summary>
        private async void btnActive_Click(object? sender, EventArgs e)
        {
            AppendDebugLog(FormatLogMessage("btnActive pressed - calling _protocol.High().")); // Trace user action.
            if (!EnsureConnected())
            {
                return; // Cannot change TX state without an open port.
            }

            AppendDebugLog(FormatLogMessage("Invoking _protocol.High() to drive TX high.")); // Clarify electrical behavior.
            try
            {
                await Task.Run(() => _protocol!.high()); // Toggle control lines on background thread.
                AppendLogBoth("TX set to Active (high). Charger simulation enabled."); // Show user the state change.
                AppendDebugLog(FormatLogMessage(
                    $"TX State after High: BreakState={_protocol!.port.BreakState}, DtrEnable={_protocol.port.DtrEnable}, RtsEnable={_protocol.port.RtsEnable}"
                )); // Log resulting control-line states.
            }
            catch (Exception ex)
            {
                LogError("Failed to set TX to Active (high).", ex); // Provide actionable error output.
            }
        }

        /// <summary>
        /// Initiates a comprehensive battery health report by invoking <see cref="M18Protocol.HealthReport"/>.
        /// The method reads multiple register blocks from the battery BMS and prints human-readable
        /// diagnostics to the log window.
        /// </summary>
        private async void btnHealthReport_Click(object? sender, EventArgs e)
        {
            AppendDebugLog(FormatLogMessage("btnHealthReport pressed - calling _protocol.HealthReport().")); // Trace user action.
            if (!EnsureConnected())
            {
                return; // Skip if no connection available.
            }

            try
            {
                AppendDebugLog(FormatLogMessage("Starting health report collection (mirrors m18.py health()).")); // Note parity with Python script.
                var report = await Task.Run(() =>
                {
                    // Use the existing health() method and capture its output.
                    // We'll redirect Console output to a string.
                    using (var sw = new System.IO.StringWriter())
                    {
                        var originalOut = Console.Out;
                        Console.SetOut(sw);
                        _protocol!.health(true); // Call the health method (force_refresh: true)
                        Console.SetOut(originalOut);
                        return sw.ToString();
                    }
                }); // Run heavy register reads off UI thread.
                AppendLog("=== Health report ==="); // Header in simple log.
                foreach (var line in report.Split(new[] { "\r\n", "\n" }, StringSplitOptions.None))
                {
                    AppendLog(line); // Preserve line breaks by appending each separately.
                }
                AppendLog("Health report complete."); // Footer for clarity.
                AppendDebugLog(FormatLogMessage("Health report appended to output.")); // Debug trace.
            }
            catch (Exception ex)
            {
                LogError("Health report failed.", ex); // Surface exceptions (timeout, parsing errors).
            }
        }

        /// <summary>
        /// Issues a reset command to the battery by toggling BREAK/DTR and sending the SYNC byte via
        /// <see cref="M18Protocol.Reset"/>. This simulates a charger reset line pulsing low/high.
        /// </summary>
        private async void btnReset_Click(object? sender, EventArgs e)
        {
            LogDebugAction("Requesting _protocol.Reset()."); // Note action for trace.
            if (!EnsureConnected())
            {
                return; // Cannot reset without open port.
            }

            try
            {
                AppendDebugLog("Sending reset sequence (BREAK/DTR + SYNC)."); // Explain protocol handshake.
                var success = await Task.Run(() => _protocol!.reset()); // Execute reset on worker thread; toggles control lines and reads response.
                AppendLogBoth(success ? "Reset command acknowledged by device." : "Reset command did not receive expected response."); // Inform user of result.
            }
            catch (Exception ex)
            {
                LogError("Reset failed.", ex); // Show errors such as port access issues.
            }
        }

        /// <summary>
        /// Copies all simple log output to the clipboard, allowing users to paste logs into emails
        /// or issue reports.
        /// </summary>
        private void btnCopyOutput_Click(object? sender, EventArgs e)
        {
            LogDebugAction("Copying output via btnCopyOutput_Click()."); // Record action.
            if (string.IsNullOrEmpty(rtbOutput.Text))
            {
                AppendLogBoth("No output to copy."); // Warn when nothing to copy.
                return; // Exit early to avoid placing empty text on clipboard.
            }

            Clipboard.SetText(rtbOutput.Text); // Use System.Windows.Forms.Clipboard to place text into OS clipboard.
            AppendLogBoth("Output copied to clipboard."); // Confirm to user.
        }

        /// <summary>
        /// Ensures there is an active connection before executing protocol operations. Shows a
        /// MessageBox when not connected so the user knows to click Connect first.
        /// </summary>
        private bool EnsureConnected()
        {
            LogDebugAction(FormatLogMessage("Checking EnsureConnected().")); // Trace call origin.
            if (_protocol != null)
            {
                return true; // Connection exists, safe to proceed.
            }

            AppendLog("No active connection. Please connect to a serial port first."); // User-friendly guidance.
            MessageBox.Show("Please connect to a serial port first.", "Connection required", MessageBoxButtons.OK, MessageBoxIcon.Warning); // Modal warning clarifies next step.
            return false; // Signal caller to abort operation.
        }

        /// <summary>
        /// Wrapper around SerialPortUtil to retrieve detailed port metadata, keeping the logic
        /// isolated for easier unit testing and mocking.
        /// </summary>
        private List<SerialPortDisplay> GetSerialPortInfos()
        {
            return SerialPortUtil.EnumerateDetailedPorts(AppendDebugLog); // Pass debug logger to capture enumeration details.
        }

        /// <summary>
        /// Executes a quick FT232 communication test against the selected port by toggling control
        /// lines and sending a byte. Helps verify USB-UART hardware is responsive.
        /// </summary>
        private async void btnTestFT232_Click(object? sender, EventArgs e)
        {
            LogDebugAction("Requesting Test FT232 operation."); // Trace user action.

            if (cmbBxSerialPort.SelectedItem is not SerialPortDisplay selectedPort)
            {
                AppendLog("No serial port selected. Please choose a port before testing."); // Provide guidance.
                MessageBox.Show("Please select a serial port before testing.", "Serial Port", MessageBoxButtons.OK, MessageBoxIcon.Warning); // Block until user acknowledges.
                return; // Abort test.
            }

            var selectedDescription = _selectedPortDescription ?? selectedPort.DisplayName; // Friendly name for messages.

            AppendLog($"Testing FT232 on {selectedDescription}..."); // Inform user test is starting.
            LogDebugAction($"Testing FT232 on {selectedDescription}."); // Duplicate in debug log.

            var testResult = await Task.Run(() => TestSerialDevice(selectedPort)); // Run test on background thread to keep UI fluid.

            if (testResult.Success)
            {
                AppendLog($"Device responded successfully on {selectedPort.PortName}."); // Success message for user.
                LogDebugAction($"Device responded successfully on {selectedPort.PortName}."); // Debug confirmation.
            }
            else
            {
                AppendLog($"No response / failed to communicate with device on {selectedPort.PortName}{(string.IsNullOrWhiteSpace(testResult.ErrorMessage) ? string.Empty : $": {testResult.ErrorMessage}")}."); // Provide failure details.
                LogDebugAction($"No response / failed to communicate with device on {selectedPort.PortName}{(string.IsNullOrWhiteSpace(testResult.ErrorMessage) ? string.Empty : $": {testResult.ErrorMessage}")}."); // Debug echo.
            }
        }

        /// <summary>
        /// Opens the specified port with the FTDI-friendly serial settings and performs a minimal
        /// control-line toggle plus a single-byte write to check for driver/hardware responsiveness.
        /// </summary>
        private static (bool Success, string? ErrorMessage) TestSerialDevice(SerialPortDisplay port)
        {
            try
            {
                using var serialPort = new SerialPort(port.PortName, 4800, Parity.None, 8, StopBits.Two)
                {
                    ReadTimeout = 500, // Limit read blocking to half a second to avoid hanging the test.
                    WriteTimeout = 500, // Avoid hanging on write if driver misbehaves.
                    DtrEnable = true, // Assert DTR to mimic idle charger line initially.
                    RtsEnable = true // Assert RTS as well; some devices power LEDs or buffers off this line.
                };

                serialPort.Open(); // Acquire OS handle to COM port; toggles control lines instantly.

                serialPort.DtrEnable = !serialPort.DtrEnable; // Flip DTR once to ensure hardware responds to control changes.
                serialPort.RtsEnable = !serialPort.RtsEnable; // Flip RTS similarly; useful for FT232 loopback LEDs.

                serialPort.Write(new byte[] { 0x00 }, 0, 1); // Send a single zero byte out TX to verify TX data path.

                return (true, null); // Success indicates driver and hardware are reachable.
            }
            catch (Exception ex)
            {
                return (false, ex.Message); // Return error message so caller can log it.
            }
        }

        /// <summary>
        /// Appends a message to the primary output log after prefixing with a timestamp.
        /// </summary>
        private void AppendLog(string message)
        {
            AppendSimpleLog(FormatLogMessage(message)); // Reuse helper to add timestamp and write to RichTextBox.
        }

        /// <summary>
        /// Appends a message to both the simple log and debug log so the text appears in two tabs.
        /// </summary>
        private void AppendLogBoth(string message)
        {
            var formatted = FormatLogMessage(message); // Create timestamped text once.
            AppendSimpleLog(formatted); // Show in user-friendly log window.
            AppendDebugLog(formatted); // Also show in verbose debug tab.
        }

        /// <summary>
        /// Writes text into the primary rich text box, marshaling to the UI thread if necessary so
        /// background tasks can safely log without cross-thread exceptions.
        /// </summary>
        private void AppendSimpleLog(string formattedMessage)
        {
            if (rtbOutput.InvokeRequired)
            {
                rtbOutput.Invoke(new Action(() => AppendSimpleLog(formattedMessage))); // Marshal to UI thread.
                return; // Exit current thread path.
            }

            var prefix = _hasAppendedLog ? Environment.NewLine : string.Empty; // Insert newline if previous messages exist.
            rtbOutput.AppendText($"{prefix}{formattedMessage}"); // Append timestamped message.
            rtbOutput.SelectionStart = rtbOutput.TextLength; // Move caret to end to keep view updated.
            rtbOutput.ScrollToCaret(); // Auto-scroll so latest text is visible.
            _hasAppendedLog = true; // Record that log has content.
        }

        /// <summary>
        /// Writes text into the advanced output rich text box (used for protocol-level logs),
        /// marshaling to the UI thread when invoked from background tasks.
        /// </summary>
        private void AppendAdvancedLog(string formattedMessage)
        {
            if (rtbAdvOutput.InvokeRequired)
            {
                rtbAdvOutput.Invoke(new Action(() => AppendAdvancedLog(formattedMessage))); // Ensure UI-thread access.
                return; // Prevent cross-thread access.
            }

            var prefix = _hasAppendedAdvancedLog ? Environment.NewLine : string.Empty; // Add newline after first entry.
            rtbAdvOutput.AppendText($"{prefix}{formattedMessage}"); // Append formatted message.
            rtbAdvOutput.SelectionStart = rtbAdvOutput.TextLength; // Move caret to end.
            rtbAdvOutput.ScrollToCaret(); // Auto-scroll to maintain visibility.
            _hasAppendedAdvancedLog = true; // Track that text exists.
        }

        /// <summary>
        /// Creates a timestamped log message string using millisecond resolution to help correlate
        /// serial I/O timing.
        /// </summary>
        private string FormatLogMessage(string message)
        {
            return $"{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} - {message}"; // Compose human-readable timestamp + message.
        }

        /// <summary>
        /// Writes a formatted message to all log panes (simple, advanced, debug) to keep them in sync.
        /// </summary>
        private void AppendProtocolLog(string message)
        {
            var formattedMessage = FormatLogMessage(message); // Timestamp once for consistency.
            AppendSimpleLog(formattedMessage); // User-friendly log.
            AppendAdvancedLog(formattedMessage); // Protocol log.
            AppendDebugLog(formattedMessage); // Debug log.
        }

        /// <summary>
        /// Logs an error context with exception details and shows a MessageBox to alert the user.
        /// </summary>
        private void LogError(string context, Exception exception)
        {
            var fullMessage = $"{context} Error details: {exception}"; // Combine context and exception message/stack trace.
            AppendLogBoth(fullMessage); // Write to logs for persistence.
            MessageBox.Show(fullMessage, "Serial Port Error", MessageBoxButtons.OK, MessageBoxIcon.Error); // Display blocking error dialog.
        }

        /// <summary>
        /// Applies checkbox settings to the protocol instance so TX/RX byte logging aligns with user
        /// preferences, and wires the protocol's TxLogger/RxLogger delegates to the UI log writers.
        /// </summary>
        private void ApplyProtocolLoggingPreferences()
        {
            if (_protocol == null)
            {
                return; // Nothing to configure if no active protocol.
            }

            _protocol.PRINT_TX = chkbxTXLog.Checked; // Mirror checkbox to protocol flag controlling TX byte echo.
            _protocol.PRINT_RX = chkboxRxLog.Checked; // Mirror checkbox to protocol flag controlling RX byte echo.
            _protocol.TxLogger = message =>
            {
                AppendProtocolLog(message); // Route TX log messages into all log panes.
            };
            _protocol.RxLogger = message =>
            {
                AppendProtocolLog(message); // Route RX log messages into all log panes.
            };
        }

        /// <summary>
        /// Updates protocol TX logging preference when the TX checkbox changes.
        /// </summary>
        private void chkbxTXLog_CheckedChanged(object? sender, EventArgs e)
        {
            if (_protocol != null)
            {
                _protocol.PRINT_TX = chkbxTXLog.Checked; // Immediately reflect UI change in protocol.
            }
        }

        /// <summary>
        /// Updates protocol RX logging preference when the RX checkbox changes.
        /// </summary>
        private void chkboxRxLog_CheckedChanged(object? sender, EventArgs e)
        {
            if (_protocol != null)
            {
                _protocol.PRINT_RX = chkboxRxLog.Checked; // Immediately reflect UI change in protocol.
            }
        }

        /// <summary>
        /// Convenience wrapper to send a debug message to the dedicated debug log pane.
        /// </summary>
        private void LogDebugAction(string message)
        {
            AppendDebugLog(message); // Delegates to AppendDebugLog for thread-safe logging.
        }

        /// <summary>
        /// Appends text to the debug rich text box with optional timestamping. Invocations from
        /// background threads are marshaled to the UI thread to avoid InvalidOperationException.
        /// </summary>
        private void AppendDebugLog(string message)
        {
            if (rtbDebugOutput.InvokeRequired)
            {
                rtbDebugOutput.Invoke(new Action(() => AppendDebugLog(message))); // Marshal to UI thread if needed.
                return; // Stop processing on worker thread.
            }

            var prefix = _hasAppendedDebugLog ? Environment.NewLine : string.Empty; // Add newline after first message.
            var formatted = message.Contains("- ") ? message : FormatLogMessage(message); // Preserve existing timestamps if provided.
            rtbDebugOutput.AppendText($"{prefix}{formatted}"); // Write to debug output box.
            rtbDebugOutput.SelectionStart = rtbDebugOutput.TextLength; // Move caret to end.
            rtbDebugOutput.ScrollToCaret(); // Auto-scroll to newest entry.
            _hasAppendedDebugLog = true; // Note content exists.
        }

        /// <summary>
        /// Enables or disables UI controls based on connection state so users cannot issue protocol
        /// commands before opening a port.
        /// </summary>
        private void UpdateConnectionUi(bool connected)
        {
            btnConnect.Enabled = !connected; // Disable Connect when connected to prevent double opens.
            btnDisconnect.Enabled = connected; // Enable Disconnect to allow clean closure.
            btnIdle.Enabled = connected; // Only allow TX toggling when port is open.
            btnActive.Enabled = connected; // Only allow TX toggling when port is open.
            btnHealthReport.Enabled = connected; // Health report requires open protocol.
            btnReset.Enabled = connected; // Reset requires open protocol.
            btnCopyOutput.Enabled = true; // Copy is always allowed because it is read-only.
            btnTestFT232.Enabled = !connected; // Prevent running FT232 test while another session holds the port.
            cmbBxSerialPort.Enabled = !connected; // Lock selection to avoid confusion while connected.
            btnRefresh.Enabled = !connected; // Avoid refresh while port is open to prevent handle conflicts.
        }

        /// <summary>
        /// Attempts to disconnect gracefully when the form is closing. This prevents dangling COM
        /// handles and leaves TX in idle (safe) state.
        /// </summary>
        private async void frmMain_FormClosing(object? sender, FormClosingEventArgs e)
        {
            AppendDebugLog(FormatLogMessage("Form closing requested - attempting clean disconnect.")); // Trace closure intent.

            try
            {
                await DisconnectAsync(false); // Do not show user messages to avoid blocking closure.
            }
            catch (Exception ex)
            {
                AppendDebugLog(FormatLogMessage($"Form closing disconnect encountered an error: {ex.GetType().Name} - {ex.Message}")); // Log but do not rethrow to avoid crash.
            }
        }

        /// <summary>
        /// Stub for RichTextBox text change event; kept for demonstration of event wiring.
        /// </summary>
        private void rtbOutput_TextChanged(object sender, EventArgs e)
        {
            // Could auto-save logs or update counters; not needed currently.
        }

        /// <summary>
        /// Duplicate combo box change handler generated by designer; kept for completeness.
        /// </summary>
        private void cmbBxSerialPort_SelectedIndexChanged_1(object sender, EventArgs e)
        {
            // All selection logic handled in cmbBxSerialPort_SelectedIndexChanged; this remains empty.
        }

        /// <summary>
        /// Stub button handler reserved for future UI actions.
        /// </summary>
        private void button1_Click(object sender, EventArgs e)
        {
            // Intentionally left blank to illustrate event handler shape.
        }

        /// <summary>
        /// Sends a raw byte (0xAA) and waits for a response to validate echo/loopback behavior on
        /// the open serial port. This is similar to a ping test for UART communications.
        /// </summary>
        private void btnTestEcho_Click(object sender, EventArgs e)
        {
            rtbDebugOutput.AppendText($"{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} - Starting raw echo test on COM{_protocol?.port.PortName ?? "??"}\n"); // Timestamp test start with chosen port name.
            try
            {
                if (_protocol?.port.IsOpen != true)
                {
                    rtbDebugOutput.AppendText($"{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} - Serial port not open. Connect first.\n"); // Warn user that port must be open.
                    return; // Exit early because no active SerialPort exists.
                }

                _protocol.port.DiscardInBuffer(); // Clear inbound buffer to remove stale bytes before test.

                byte[] send = { 0xAA }; // Single SYNC-like byte to transmit; echoed devices should return it.
                _protocol.port.Write(send, 0, 1); // Write to UART TX line; FT232 shifts bits out over USB-UART bridge.
                rtbDebugOutput.AppendText($"{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} - Sent byte 0xAA.\n"); // Confirm transmission to user.

                int response = _protocol.port.ReadByte(); // Block up to ReadTimeout waiting for one byte on RX.
                if (response >= 0)
                {
                    rtbDebugOutput.AppendText($"{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} - Received byte: 0x{response:X2}\n"); // Show returned byte in hex for clarity.
                }
                else
                {
                    rtbDebugOutput.AppendText($"{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} - No byte received (timeout).\n"); // Note absence of response.
                }
            }
            catch (Exception ex)
            {
                rtbDebugOutput.AppendText($"{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} - Exception: {ex.Message}\n"); // Capture and display any exceptions (IO errors, timeouts).
            }
        }
    }
}
